\documentclass[Main]{subfiles}
\begin{document}

%This part shall contain your own reflections about the main challenges envisaged for precise and accurate specifications of IT systems and ways you see to mitigate such challenges from both a customer and a supplier perspective and set it in perspective to the articles presented in the course (around 1 page).

\section{Concluding Remarks}
Another technique is winning its way to the engineers -- task-description.
By making figures, tables and waving their arms engineers some times manage to convince a potential customer of a piece of software he can create.
Engineers have always spoken in weird terms and phrases -- always to each other any rarely with others.
Even though a customer can bind the engineers to the contract and sue him for not following it, it has always been in both the contractor and the customer's best interest to complete the contract.
Should it fail it will result in loss of money, loss of valuable time and possible give a bad reputation for wasting money.
Task-description can very well be, what the agile method was for the waterfall-model, regarding SRS documents.
The art of getting others to pay the engineers for a piece of software is therefor a difficult task, since the software language contains a lot of these weird terms and phrases.
The engineer can spend many hours making use cases that will cover the customer's needs, but maybe to discover some form of miscommunication between him and the customer.
The standard approach of making the SRS has been with use cases, explaining what the user of the system must do, how the system will use the input, and what will be the output.
There are different ways for doing this but making a SRS is the norm.
This technique has worked for years but has resulted in misunderstanding -- because use cases are still the language of the engineers -- clear to them but rubbish to the customer.
Unless the customer knows a good portion about software making this has been a risky step to make, because the engineer charges a lot of money for this, and the customer only has a stack of papers with weird diagrams and word of which he hopes express what he actually wants and needs.
With this technique the engineer can talk the customer's language most of the time while still making the specific details of the systems behavior.
\\
\\
Writing an SRS with the customer can seems tedious for a result-driven engineer who is exploding with idea of how to create the system in code.
But many surprises can pop up doing development, and if the engineer haven't calculated for these they can result in a lot of wasted time and redesign of the system.
Therefor can the process of understanding the customer's actual needs be a great help for the developers -- letting the customer sell their idea of a system to the engineer can be better, than letting the engineer sell his idea of the customer's system to the customer.
\\
\\
Writing the SRS isn't easy.
At first the customer will have a lot of good ideas for the system -- actual needs as well as features to make it nice and neat.
Some requirements will matter less than others, some will be more vague than others, and these must be noted to be specified later.
Seven critical steps must be taken to ensure, that the SRS becomes a final version without mistakes which will blow up later in the design phase or worse, the implementation phase.

To overcome these insure the seven steps will get all requirements the customer has are written in the document.
The requirements must not be up for interpretation and all figures, tables, functionality, performance and design decisions must be labeled and used as references in the document.
The requirements cannot conflict with each other and must be verifiable. 
A good idea is to categories the requirements so they easily can be changed later.
Including backward and forward traceability matrices can seem like a serious overkill, but should the requirements change this is a nice table to look up where it might affect other requirements.
These tables are also a useful tool to look up a) if all requirements have been added and b) where a certain requirement or feature has root in case of conflict or similar.




\end{document}